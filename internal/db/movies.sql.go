// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: movies.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	pgvector_go "github.com/pgvector/pgvector-go"
)

const findSimilarMovies = `-- name: FindSimilarMovies :many
SELECT id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding FROM movies
ORDER BY embedding <=> $1
LIMIT 30
`

func (q *Queries) FindSimilarMovies(ctx context.Context, embedding pgvector_go.Vector) ([]Movie, error) {
	rows, err := q.query(ctx, q.findSimilarMoviesStmt, findSimilarMovies, embedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.OriginalTitle,
			&i.Overview,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Budget,
			&i.Revenue,
			&i.Popularity,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Status,
			&i.Tagline,
			&i.Homepage,
			&i.OriginalLanguage,
			&i.Adult,
			&i.BackdropPath,
			&i.PosterPath,
			&i.CollectionID,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMovies = `-- name: GetAllMovies :many
SELECT id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding FROM movies
ORDER BY id
LIMIT $1 OFFSET $2
`

type GetAllMoviesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllMovies(ctx context.Context, arg GetAllMoviesParams) ([]Movie, error) {
	rows, err := q.query(ctx, q.getAllMoviesStmt, getAllMovies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.OriginalTitle,
			&i.Overview,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Budget,
			&i.Revenue,
			&i.Popularity,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Status,
			&i.Tagline,
			&i.Homepage,
			&i.OriginalLanguage,
			&i.Adult,
			&i.BackdropPath,
			&i.PosterPath,
			&i.CollectionID,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovie = `-- name: GetMovie :one
SELECT id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding FROM movies
WHERE id = $1
`

func (q *Queries) GetMovie(ctx context.Context, id int32) (Movie, error) {
	row := q.queryRow(ctx, q.getMovieStmt, getMovie, id)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Budget,
		&i.Revenue,
		&i.Popularity,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Status,
		&i.Tagline,
		&i.Homepage,
		&i.OriginalLanguage,
		&i.Adult,
		&i.BackdropPath,
		&i.PosterPath,
		&i.CollectionID,
		&i.Embedding,
	)
	return i, err
}

const getMovieDetails = `-- name: GetMovieDetails :one
WITH cast_members_agg AS (
  SELECT 
    credits_cast_member.credit_id,
    json_agg(
      json_build_object(
        'id', cast_members.id,
        'name', cast_members.name,
        'profile_path', cast_members.profile_path
      )
    ) AS cast_members
  FROM credits_cast_member
  JOIN cast_members ON credits_cast_member.member_id = cast_members.id
  GROUP BY credits_cast_member.credit_id
),
crew_members_agg AS (
  SELECT 
    credits_crew_member.credit_id,
    json_agg(
      json_build_object(
        'id', crew_members.id,
        'name', crew_members.name,
        'profile_path', crew_members.profile_path
      )
    ) AS crew_members
  FROM credits_crew_member
  JOIN crew_members ON credits_crew_member.member_id = crew_members.id
  GROUP BY credits_crew_member.credit_id
),
genres_agg AS (
  SELECT 
    movie_id,
    json_agg(
      json_build_object(
        'id', genres.id,
        'name', genres.name
      )
    ) AS genres
  FROM movie_genres
  JOIN genres ON movie_genres.genre_id = genres.id
  GROUP BY movie_id
),
countries_agg AS (
  SELECT 
    movie_id,
    json_agg(
      json_build_object(
        'name', countries.name
      )
    ) AS countries
  FROM movie_countries
  JOIN countries ON movie_countries.country_id = countries.iso_3166_1
  GROUP BY movie_id
),
languages_agg AS (
  SELECT 
    movie_id,
    json_agg(
      json_build_object(
        'name', languages.name,
        'english_name', languages.english_name
      )
    ) AS languages
  FROM movie_languages
  JOIN languages ON movie_languages.language_id = languages.iso_639_1
  GROUP BY movie_id
),
production_companies_agg AS (
  SELECT 
    movie_id,
    json_agg(
      json_build_object(
        'name', production_companies.name,
        'logo_path', production_companies.logo_path
      )
    ) AS production_companies
  FROM movie_production_companies
  JOIN production_companies ON movie_production_companies.company_id = production_companies.id
  GROUP BY movie_id
)
SELECT 
  movies.id,
  movies.title,
  movies.overview,
  movies.backdrop_path,
  movies.budget,
  movies.popularity,
  movies.poster_path,
  movies.release_date,
  movies.revenue,
  movies.runtime,
  movies.vote_average,
  movies.vote_count,
  movies.status,
  COALESCE(collections.name, '') AS collection_name,
  COALESCE(collections.poster_path, '') AS collection_poster_path,
  COALESCE(cast_members_agg.cast_members, '[]'::json) AS cast_members,
  COALESCE(crew_members_agg.crew_members, '[]'::json) AS crew_members,
  COALESCE(genres_agg.genres, '[]'::json) AS genres,
  COALESCE(countries_agg.countries, '[]'::json) AS countries,
  COALESCE(languages_agg.languages, '[]'::json) AS languages,
  COALESCE(production_companies_agg.production_companies, '[]'::json) AS production_companies
FROM 
  movies
LEFT JOIN collections ON movies.collection_id = collections.id
LEFT JOIN cast_members_agg ON cast_members_agg.credit_id = movies.id
LEFT JOIN crew_members_agg ON crew_members_agg.credit_id = movies.id
LEFT JOIN genres_agg ON genres_agg.movie_id = movies.id
LEFT JOIN countries_agg ON countries_agg.movie_id = movies.id
LEFT JOIN languages_agg ON languages_agg.movie_id = movies.id
LEFT JOIN production_companies_agg ON production_companies_agg.movie_id = movies.id
WHERE
  movies.id = $1
`

type GetMovieDetailsRow struct {
	ID                   int32           `json:"id"`
	Title                string          `json:"title"`
	Overview             string          `json:"overview"`
	BackdropPath         string          `json:"backdrop_path"`
	Budget               int64           `json:"budget"`
	Popularity           float64         `json:"popularity"`
	PosterPath           string          `json:"poster_path"`
	ReleaseDate          time.Time       `json:"release_date"`
	Revenue              int64           `json:"revenue"`
	Runtime              int32           `json:"runtime"`
	VoteAverage          float64         `json:"vote_average"`
	VoteCount            int32           `json:"vote_count"`
	Status               string          `json:"status"`
	CollectionName       string          `json:"collection_name"`
	CollectionPosterPath string          `json:"collection_poster_path"`
	CastMembers          json.RawMessage `json:"cast_members"`
	CrewMembers          json.RawMessage `json:"crew_members"`
	Genres               json.RawMessage `json:"genres"`
	Countries            json.RawMessage `json:"countries"`
	Languages            json.RawMessage `json:"languages"`
	ProductionCompanies  json.RawMessage `json:"production_companies"`
}

func (q *Queries) GetMovieDetails(ctx context.Context, id int32) (GetMovieDetailsRow, error) {
	row := q.queryRow(ctx, q.getMovieDetailsStmt, getMovieDetails, id)
	var i GetMovieDetailsRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Overview,
		&i.BackdropPath,
		&i.Budget,
		&i.Popularity,
		&i.PosterPath,
		&i.ReleaseDate,
		&i.Revenue,
		&i.Runtime,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Status,
		&i.CollectionName,
		&i.CollectionPosterPath,
		&i.CastMembers,
		&i.CrewMembers,
		&i.Genres,
		&i.Countries,
		&i.Languages,
		&i.ProductionCompanies,
	)
	return i, err
}

const getMoviesByName = `-- name: GetMoviesByName :many
SELECT id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding
FROM movies
WHERE title ILIKE '%' || $1 || '%'
ORDER BY popularity DESC
LIMIT $2 OFFSET $3
`

type GetMoviesByNameParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) GetMoviesByName(ctx context.Context, arg GetMoviesByNameParams) ([]Movie, error) {
	rows, err := q.query(ctx, q.getMoviesByNameStmt, getMoviesByName, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.OriginalTitle,
			&i.Overview,
			&i.ReleaseDate,
			&i.Runtime,
			&i.Budget,
			&i.Revenue,
			&i.Popularity,
			&i.VoteAverage,
			&i.VoteCount,
			&i.Status,
			&i.Tagline,
			&i.Homepage,
			&i.OriginalLanguage,
			&i.Adult,
			&i.BackdropPath,
			&i.PosterPath,
			&i.CollectionID,
			&i.Embedding,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRandomMovie = `-- name: GetRandomMovie :one
SELECT id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding
FROM movies
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomMovie(ctx context.Context) (Movie, error) {
	row := q.queryRow(ctx, q.getRandomMovieStmt, getRandomMovie)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Budget,
		&i.Revenue,
		&i.Popularity,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Status,
		&i.Tagline,
		&i.Homepage,
		&i.OriginalLanguage,
		&i.Adult,
		&i.BackdropPath,
		&i.PosterPath,
		&i.CollectionID,
		&i.Embedding,
	)
	return i, err
}

const updateMovieEmbedding = `-- name: UpdateMovieEmbedding :exec
UPDATE movies 
SET embedding = $2
WHERE id = $1
`

type UpdateMovieEmbeddingParams struct {
	ID        int32              `json:"id"`
	Embedding pgvector_go.Vector `json:"embedding"`
}

func (q *Queries) UpdateMovieEmbedding(ctx context.Context, arg UpdateMovieEmbeddingParams) error {
	_, err := q.exec(ctx, q.updateMovieEmbeddingStmt, updateMovieEmbedding, arg.ID, arg.Embedding)
	return err
}

const upsertMovie = `-- name: UpsertMovie :one
INSERT INTO movies (
  id, title, original_title, overview, release_date, runtime, budget, revenue,
  popularity, vote_average, vote_count, status, tagline, homepage,
  original_language, adult, backdrop_path, poster_path, collection_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8,
  $9, $10, $11, $12, $13, $14,
  $15, $16, $17, $18, $19
)
ON CONFLICT (id) DO UPDATE SET
  title = EXCLUDED.title,
  original_title = EXCLUDED.original_title,
  overview = EXCLUDED.overview,
  release_date = EXCLUDED.release_date,
  runtime = EXCLUDED.runtime,
  budget = EXCLUDED.budget,
  revenue = EXCLUDED.revenue,
  popularity = EXCLUDED.popularity,
  vote_average = EXCLUDED.vote_average,
  vote_count = EXCLUDED.vote_count,
  status = EXCLUDED.status,
  tagline = EXCLUDED.tagline,
  homepage = EXCLUDED.homepage,
  original_language = EXCLUDED.original_language,
  adult = EXCLUDED.adult,
  backdrop_path = EXCLUDED.backdrop_path,
  poster_path = EXCLUDED.poster_path,
  collection_id = EXCLUDED.collection_id
RETURNING id, title, original_title, overview, release_date, runtime, budget, revenue, popularity, vote_average, vote_count, status, tagline, homepage, original_language, adult, backdrop_path, poster_path, collection_id, embedding
`

type UpsertMovieParams struct {
	ID               int32     `json:"id"`
	Title            string    `json:"title"`
	OriginalTitle    string    `json:"original_title"`
	Overview         string    `json:"overview"`
	ReleaseDate      time.Time `json:"release_date"`
	Runtime          int32     `json:"runtime"`
	Budget           int64     `json:"budget"`
	Revenue          int64     `json:"revenue"`
	Popularity       float64   `json:"popularity"`
	VoteAverage      float64   `json:"vote_average"`
	VoteCount        int32     `json:"vote_count"`
	Status           string    `json:"status"`
	Tagline          string    `json:"tagline"`
	Homepage         string    `json:"homepage"`
	OriginalLanguage string    `json:"original_language"`
	Adult            bool      `json:"adult"`
	BackdropPath     string    `json:"backdrop_path"`
	PosterPath       string    `json:"poster_path"`
	CollectionID     int32     `json:"collection_id"`
}

func (q *Queries) UpsertMovie(ctx context.Context, arg UpsertMovieParams) (Movie, error) {
	row := q.queryRow(ctx, q.upsertMovieStmt, upsertMovie,
		arg.ID,
		arg.Title,
		arg.OriginalTitle,
		arg.Overview,
		arg.ReleaseDate,
		arg.Runtime,
		arg.Budget,
		arg.Revenue,
		arg.Popularity,
		arg.VoteAverage,
		arg.VoteCount,
		arg.Status,
		arg.Tagline,
		arg.Homepage,
		arg.OriginalLanguage,
		arg.Adult,
		arg.BackdropPath,
		arg.PosterPath,
		arg.CollectionID,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.OriginalTitle,
		&i.Overview,
		&i.ReleaseDate,
		&i.Runtime,
		&i.Budget,
		&i.Revenue,
		&i.Popularity,
		&i.VoteAverage,
		&i.VoteCount,
		&i.Status,
		&i.Tagline,
		&i.Homepage,
		&i.OriginalLanguage,
		&i.Adult,
		&i.BackdropPath,
		&i.PosterPath,
		&i.CollectionID,
		&i.Embedding,
	)
	return i, err
}
